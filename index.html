/**
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 * DivertScanâ„¢ Core Module v2.3
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 * Master core for all DivertScan functionality
 * Â© 2026 Robert - All Rights Reserved
 * 
 * CHANGELOG v2.3:
 * - Fixed date logic: defaults to current system date, user-editable service_date
 * - Full CRUD for tickets (Create, Read, Update, Delete)
 * - Scale API integration via Web Serial API
 * - Auto-recalculate on any weight/percentage edit
 * - Export format aligned with LEED Waste Diversion Reports
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 */

const DivertScan = (function() {
    'use strict';

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // CONFIGURATION
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    const CONFIG = {
        SUPABASE_URL: 'https://cyvvlngtojagfoaitoog.supabase.co',
        SUPABASE_KEY: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImN5dnZsbmd0b2phZ2ZvYWl0b29nIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjkyODk4OTAsImV4cCI6MjA4NDg2NTg5MH0.CltpTET2wFfl5kaHFOGmUS8tR8bRFCjbtWDdVrC5r0g',
        VERSION: '2.3.0',
        LEED_V4_TARGET: 50,
        LEED_V5_TARGET: 75,
        CONTAINER_SIZES: [20, 30, 40],
        DEFAULT_CONTAINER: 30,
        
        // Scale Configuration (Avery Weigh-Tronix 1310)
        SCALE: {
            BAUD_RATE: 9600,
            DATA_BITS: 8,
            STOP_BITS: 1,
            PARITY: 'none',
            FLOW_CONTROL: 'none',
            // Weight parsing regex for common scale formats
            WEIGHT_REGEX: /(\d+\.?\d*)\s*(lb|lbs|kg|LB|LBS|KG)?/
        }
    };

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // MATERIAL DEFINITIONS - LEED v5 Compliant
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    const MATERIALS = {
        wood: { name: 'Wood/Lumber', icon: 'ğŸªµ', recyclable: true, gwpFactor: 0.03 },
        gypsum: { name: 'Gypsum/Drywall', icon: 'ğŸ§±', recyclable: true, gwpFactor: 0.12 },
        plastic: { name: 'Plastic', icon: 'â™»ï¸', recyclable: true, gwpFactor: 2.5 },
        occ: { name: 'Cardboard/OCC', icon: 'ğŸ“¦', recyclable: true, gwpFactor: 0.94 },
        metal: { name: 'Metal/Steel', icon: 'ğŸ”©', recyclable: true, gwpFactor: 1.85 },
        concrete: { name: 'Concrete', icon: 'ğŸª¨', recyclable: true, gwpFactor: 0.159 },
        block: { name: 'CMU/Block', icon: 'ğŸ§±', recyclable: true, gwpFactor: 0.159 },
        landfill: { name: 'Landfill/Trash', icon: 'ğŸ—‘ï¸', recyclable: false, gwpFactor: 0.52 }
    };

    const MATERIAL_KEYS = ['wood', 'gypsum', 'plastic', 'occ', 'metal', 'concrete', 'block', 'landfill'];

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // STATE MANAGEMENT
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    let state = {
        supabase: null,
        user: null,
        currentProject: null,
        
        // Scale connection
        scalePort: null,
        scaleReader: null,
        scaleConnected: false,
        lastScaleReading: null,
        
        // Current ticket being edited (for CRUD)
        editingTicketId: null,
        
        // Active ticket session
        ticketSession: {
            id: null,                    // UUID if editing existing ticket
            ticketNumber: null,
            serviceDate: null,           // NEW: User-editable service date
            createdAt: null,             // System timestamp when ticket was created
            grossLbs: null,
            tareLbs: null,
            netLbs: null,
            netTons: null,
            hauler: null,
            containerSize: 30,
            scaleTicketImage: null,
            debrisImages: [],
            materialBreakdown: {},
            diversionRate: 0,
            co2eAvoided: 0,
            calculatedBreakdown: {},
            gpsLat: null,
            gpsLng: null,
            ipAddress: null,
            capturedAt: null,
            lastModified: null,          // Track edits
            modifiedBy: null
        },
        
        openaiKey: localStorage.getItem('divertscan_openai') || '',
        isOnline: navigator.onLine
    };

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // UTILITY FUNCTIONS
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    function toast(message, type = 'info') {
        const toastEl = document.getElementById('toast');
        if (!toastEl) { console.log(`[${type}] ${message}`); return; }
        toastEl.textContent = message;
        toastEl.className = `toast ${type} show`;
        setTimeout(() => toastEl.classList.remove('show'), 3000);
    }

    function formatNumber(num) {
        if (num === null || num === undefined) return '0';
        return Number(num).toLocaleString('en-US');
    }

    /**
     * Get current system date in YYYY-MM-DD format
     * FIX: Always use actual current date, not hardcoded
     */
    function getCurrentDate() {
        const now = new Date();
        return now.toISOString().split('T')[0];
    }

    /**
     * Format date for display (MM/DD/YY)
     */
    function formatDate(date) {
        if (!date) return '';
        const d = new Date(date + 'T00:00:00'); // Prevent timezone shift
        return d.toLocaleDateString('en-US', { month: '2-digit', day: '2-digit', year: '2-digit' });
    }

    /**
     * Format date for database (YYYY-MM-DD)
     */
    function formatDateDB(date) {
        if (!date) return getCurrentDate();
        if (date instanceof Date) {
            return date.toISOString().split('T')[0];
        }
        // Already in correct format
        if (/^\d{4}-\d{2}-\d{2}$/.test(date)) {
            return date;
        }
        // Convert MM/DD/YY to YYYY-MM-DD
        const parts = date.split('/');
        if (parts.length === 3) {
            const year = parts[2].length === 2 ? '20' + parts[2] : parts[2];
            return `${year}-${parts[0].padStart(2,'0')}-${parts[1].padStart(2,'0')}`;
        }
        return getCurrentDate();
    }

    function generateAuditId() {
        const year = new Date().getFullYear();
        const random = Math.random().toString(36).substring(2, 6).toUpperCase();
        const seq = Date.now().toString().slice(-5);
        return `DS-${year}-${seq}-${random}`;
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // WEIGHT & MATERIAL CALCULATIONS (Auto-recalculate on edit)
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    /**
     * Calculate net weight from gross and tare
     */
    function calculateNetWeight(grossLbs, tareLbs) {
        const gross = parseFloat(grossLbs) || 0;
        const tare = parseFloat(tareLbs) || 0;
        const netLbs = gross - tare;
        return {
            netLbs: Math.max(0, netLbs),
            netTons: Math.max(0, netLbs / 2000)
        };
    }

    /**
     * Calculate material tonnages from percentages
     * AUTO-RECALCULATES when weights or percentages change
     */
    function calculateMaterialTonnages(percentages, netTons) {
        const breakdown = {};
        let totalDivertedPct = 0;
        let totalCO2e = 0;

        for (const key of MATERIAL_KEYS) {
            const pct = parseFloat(percentages[key]) || 0;
            const tons = (pct / 100) * netTons;
            const material = MATERIALS[key];
            const co2e = tons * (material?.gwpFactor || 0);

            breakdown[key] = {
                pct: pct,
                tons: tons,
                co2e: co2e,
                recyclable: material?.recyclable || false
            };

            if (material?.recyclable && key !== 'landfill') {
                totalDivertedPct += pct;
            }
            totalCO2e += co2e;
        }

        return {
            breakdown,
            diversionRate: Math.round(totalDivertedPct),
            totalCO2e,
            meetsLEEDv4: totalDivertedPct >= CONFIG.LEED_V4_TARGET,
            meetsLEEDv5: totalDivertedPct >= CONFIG.LEED_V5_TARGET
        };
    }

    /**
     * Validate material percentages total 100%
     */
    function validateMaterialTotal(percentages) {
        let total = 0;
        for (const key of MATERIAL_KEYS) {
            total += parseFloat(percentages[key]) || 0;
        }
        return {
            total: Math.round(total * 10) / 10,
            valid: Math.abs(total - 100) < 0.5,
            message: Math.abs(total - 100) < 0.5 ? 'Valid' : `Total is ${total.toFixed(1)}%, must equal 100%`
        };
    }

    /**
     * MASTER RECALCULATION - Call this whenever weights or percentages change
     */
    function recalculateTicket() {
        const session = state.ticketSession;
        
        // Recalculate net weight
        if (session.grossLbs !== null && session.tareLbs !== null) {
            const net = calculateNetWeight(session.grossLbs, session.tareLbs);
            session.netLbs = net.netLbs;
            session.netTons = net.netTons;
        }

        // Recalculate material tonnages if we have percentages and net tons
        if (Object.keys(session.materialBreakdown).length > 0 && session.netTons) {
            const result = calculateMaterialTonnages(session.materialBreakdown, session.netTons);
            session.diversionRate = result.diversionRate;
            session.co2eAvoided = result.totalCO2e;
            session.calculatedBreakdown = result.breakdown;
        }

        // Mark as modified
        session.lastModified = new Date().toISOString();
        session.modifiedBy = state.user?.email || 'unknown';

        return session;
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // TICKET SESSION MANAGEMENT
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    /**
     * Initialize a new ticket session with CORRECT current date
     */
    function initTicketSession() {
        const currentDate = getCurrentDate();
        
        state.ticketSession = {
            id: null,
            ticketNumber: null,
            serviceDate: currentDate,        // DEFAULT TO TODAY
            createdAt: new Date().toISOString(),
            grossLbs: null,
            tareLbs: null,
            netLbs: null,
            netTons: null,
            hauler: null,
            containerSize: 30,
            scaleTicketImage: null,
            debrisImages: [],
            materialBreakdown: {},
            diversionRate: 0,
            co2eAvoided: 0,
            calculatedBreakdown: {},
            gpsLat: null,
            gpsLng: null,
            ipAddress: null,
            capturedAt: new Date().toISOString(),
            lastModified: null,
            modifiedBy: null
        };
        
        state.editingTicketId = null;
        return state.ticketSession;
    }

    /**
     * Load existing ticket into session for editing
     */
    function loadTicketForEdit(ticket) {
        state.editingTicketId = ticket.id;
        
        state.ticketSession = {
            id: ticket.id,
            ticketNumber: ticket.ticket_number,
            serviceDate: ticket.service_date || ticket.ticket_date,
            createdAt: ticket.created_at,
            grossLbs: ticket.gross_lbs,
            tareLbs: ticket.tare_lbs,
            netLbs: ticket.net_lbs,
            netTons: ticket.net_tons,
            hauler: ticket.hauler,
            containerSize: ticket.container_size || 30,
            scaleTicketImage: ticket.scale_ticket_image,
            debrisImages: ticket.debris_images ? JSON.parse(ticket.debris_images) : [],
            materialBreakdown: {
                wood: ticket.wood_pct || 0,
                gypsum: ticket.gypsum_pct || 0,
                plastic: ticket.plastic_pct || 0,
                occ: ticket.occ_pct || 0,
                metal: ticket.metal_pct || 0,
                concrete: ticket.concrete_pct || 0,
                block: ticket.block_pct || 0,
                landfill: ticket.landfill_pct || 0
            },
            diversionRate: ticket.diversion_pct || 0,
            co2eAvoided: ticket.co2e_avoided || 0,
            calculatedBreakdown: {
                wood: { pct: ticket.wood_pct, tons: ticket.wood_tons },
                gypsum: { pct: ticket.gypsum_pct, tons: ticket.gypsum_tons },
                plastic: { pct: ticket.plastic_pct, tons: ticket.plastic_tons },
                occ: { pct: ticket.occ_pct, tons: ticket.occ_tons },
                metal: { pct: ticket.metal_pct, tons: ticket.metal_tons },
                concrete: { pct: ticket.concrete_pct, tons: ticket.concrete_tons },
                block: { pct: ticket.block_pct, tons: ticket.block_tons },
                landfill: { pct: ticket.landfill_pct, tons: ticket.landfill_tons }
            },
            gpsLat: ticket.gps_lat,
            gpsLng: ticket.gps_lng,
            ipAddress: ticket.ip_address,
            capturedAt: ticket.captured_at,
            lastModified: ticket.last_modified,
            modifiedBy: ticket.modified_by
        };

        return state.ticketSession;
    }

    /**
     * Update ticket session with new data and auto-recalculate
     */
    function updateTicketSession(data) {
        Object.assign(state.ticketSession, data);
        return recalculateTicket();
    }

    /**
     * Set material percentages and recalculate
     */
    function setMaterialPercentages(percentages) {
        const normalized = {};
        for (const key of MATERIAL_KEYS) {
            normalized[key] = parseFloat(percentages[key]) || 0;
        }
        state.ticketSession.materialBreakdown = normalized;
        return recalculateTicket();
    }

    /**
     * Update a single material percentage and recalculate
     */
    function updateMaterialPercentage(material, percentage) {
        if (!MATERIAL_KEYS.includes(material)) {
            console.warn('Invalid material:', material);
            return;
        }
        state.ticketSession.materialBreakdown[material] = parseFloat(percentage) || 0;
        return recalculateTicket();
    }

    /**
     * Get current ticket session
     */
    function getTicketSession() {
        return { ...state.ticketSession };
    }

    /**
     * Check if currently editing an existing ticket
     */
    function isEditingTicket() {
        return state.editingTicketId !== null;
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // SCALE API INTEGRATION (Web Serial API)
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    /**
     * Check if Web Serial API is supported
     */
    function isScaleSupported() {
        return 'serial' in navigator;
    }

    /**
     * Connect to scale via Web Serial API
     * For Avery Weigh-Tronix 1310 with RS-232
     */
    async function connectScale() {
        if (!isScaleSupported()) {
            toast('Web Serial API not supported. Use Chrome or Edge.', 'error');
            return false;
        }

        try {
            // Request port access
            state.scalePort = await navigator.serial.requestPort();
            
            // Open with Avery 1310 settings
            await state.scalePort.open({
                baudRate: CONFIG.SCALE.BAUD_RATE,
                dataBits: CONFIG.SCALE.DATA_BITS,
                stopBits: CONFIG.SCALE.STOP_BITS,
                parity: CONFIG.SCALE.PARITY,
                flowControl: CONFIG.SCALE.FLOW_CONTROL
            });

            state.scaleConnected = true;
            toast('Scale connected!', 'success');
            
            // Start reading
            startScaleReader();
            
            return true;
        } catch (e) {
            console.error('Scale connection error:', e);
            toast('Failed to connect to scale: ' + e.message, 'error');
            return false;
        }
    }

    /**
     * Disconnect from scale
     */
    async function disconnectScale() {
        try {
            if (state.scaleReader) {
                await state.scaleReader.cancel();
                state.scaleReader = null;
            }
            if (state.scalePort) {
                await state.scalePort.close();
                state.scalePort = null;
            }
            state.scaleConnected = false;
            toast('Scale disconnected', 'info');
        } catch (e) {
            console.error('Scale disconnect error:', e);
        }
    }

    /**
     * Start continuous reading from scale
     */
    async function startScaleReader() {
        if (!state.scalePort || !state.scalePort.readable) return;

        const decoder = new TextDecoderStream();
        const readableStreamClosed = state.scalePort.readable.pipeTo(decoder.writable);
        state.scaleReader = decoder.readable.getReader();

        let buffer = '';

        try {
            while (true) {
                const { value, done } = await state.scaleReader.read();
                if (done) break;
                
                buffer += value;
                
                // Look for weight data (varies by scale model)
                // Avery typically sends: "    1234 lb" or similar
                const lines = buffer.split(/[\r\n]+/);
                buffer = lines.pop() || '';
                
                for (const line of lines) {
                    const weight = parseScaleWeight(line);
                    if (weight !== null) {
                        state.lastScaleReading = {
                            weight: weight,
                            unit: 'lbs',
                            timestamp: new Date().toISOString(),
                            raw: line.trim()
                        };
                        
                        // Dispatch event for UI to listen to
                        window.dispatchEvent(new CustomEvent('scaleReading', {
                            detail: state.lastScaleReading
                        }));
                    }
                }
            }
        } catch (e) {
            if (e.name !== 'CancelError') {
                console.error('Scale read error:', e);
            }
        }
    }

    /**
     * Parse weight from scale output string
     */
    function parseScaleWeight(rawData) {
        if (!rawData) return null;
        
        // Try to match common scale output formats
        const match = rawData.match(CONFIG.SCALE.WEIGHT_REGEX);
        if (match) {
            let weight = parseFloat(match[1]);
            const unit = (match[2] || 'lb').toLowerCase();
            
            // Convert kg to lbs if needed
            if (unit === 'kg') {
                weight = weight * 2.20462;
            }
            
            return Math.round(weight);
        }
        
        return null;
    }

    /**
     * Fetch current scale reading (one-shot)
     * Called when user clicks "Capture Weight" button
     */
    async function fetchScaleData(type = 'gross') {
        if (!state.scaleConnected) {
            toast('Scale not connected. Click "Connect Scale" first.', 'error');
            return null;
        }

        // Use the last reading if available and recent (within 5 seconds)
        if (state.lastScaleReading) {
            const readingAge = Date.now() - new Date(state.lastScaleReading.timestamp).getTime();
            if (readingAge < 5000) {
                const weight = state.lastScaleReading.weight;
                
                // Update the appropriate field
                if (type === 'gross') {
                    updateTicketSession({ grossLbs: weight });
                    toast(`Gross weight captured: ${formatNumber(weight)} lbs`, 'success');
                } else if (type === 'tare') {
                    updateTicketSession({ tareLbs: weight });
                    toast(`Tare weight captured: ${formatNumber(weight)} lbs`, 'success');
                }
                
                return weight;
            }
        }

        toast('Waiting for scale reading...', 'info');
        
        // Wait for next reading (up to 3 seconds)
        return new Promise((resolve) => {
            const handler = (event) => {
                const weight = event.detail.weight;
                window.removeEventListener('scaleReading', handler);
                
                if (type === 'gross') {
                    updateTicketSession({ grossLbs: weight });
                    toast(`Gross weight captured: ${formatNumber(weight)} lbs`, 'success');
                } else if (type === 'tare') {
                    updateTicketSession({ tareLbs: weight });
                    toast(`Tare weight captured: ${formatNumber(weight)} lbs`, 'success');
                }
                
                resolve(weight);
            };
            
            window.addEventListener('scaleReading', handler);
            
            // Timeout after 3 seconds
            setTimeout(() => {
                window.removeEventListener('scaleReading', handler);
                toast('No scale reading received. Check connection.', 'error');
                resolve(null);
            }, 3000);
        });
    }

    /**
     * Get scale connection status
     */
    function getScaleStatus() {
        return {
            supported: isScaleSupported(),
            connected: state.scaleConnected,
            lastReading: state.lastScaleReading
        };
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // POINT-OF-CAPTURE VERIFICATION
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    async function captureGPS() {
        return new Promise((resolve) => {
            if (!navigator.geolocation) {
                resolve({ lat: null, lng: null });
                return;
            }
            navigator.geolocation.getCurrentPosition(
                (pos) => {
                    state.ticketSession.gpsLat = pos.coords.latitude;
                    state.ticketSession.gpsLng = pos.coords.longitude;
                    resolve({ lat: pos.coords.latitude, lng: pos.coords.longitude });
                },
                () => resolve({ lat: null, lng: null }),
                { enableHighAccuracy: true, timeout: 10000 }
            );
        });
    }

    async function captureIP() {
        try {
            const response = await fetch('https://api.ipify.org?format=json');
            const data = await response.json();
            state.ticketSession.ipAddress = data.ip;
            return data.ip;
        } catch (e) {
            return null;
        }
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // OPENAI GPT-4o INTEGRATION
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    async function analyzeScaleTicket(imageDataUrl) {
        const apiKey = state.openaiKey || localStorage.getItem('divertscan_openai');
        if (!apiKey) throw new Error('OpenAI API key not configured. Go to Settings.');

        const response = await fetch('https://api.openai.com/v1/chat/completions', {
            method: 'POST',
            headers: { 'Authorization': `Bearer ${apiKey}`, 'Content-Type': 'application/json' },
            body: JSON.stringify({
                model: 'gpt-4o',
                messages: [{
                    role: 'user',
                    content: [
                        { type: 'text', text: `Extract data from this scale ticket. Return ONLY valid JSON:
{"ticket_number":"string or null","date":"MM/DD/YY or null","hauler":"string or null","gross_lbs":number or null,"tare_lbs":number or null,"net_lbs":number or null,"commodity":"string or null","confidence":0-100}` },
                        { type: 'image_url', image_url: { url: imageDataUrl } }
                    ]
                }],
                max_tokens: 500
            })
        });

        const data = await response.json();
        if (data.error) throw new Error(data.error.message);

        const content = data.choices[0].message.content;
        const jsonMatch = content.match(/\{[\s\S]*\}/);
        if (!jsonMatch) throw new Error('Could not parse OCR response');

        const result = JSON.parse(jsonMatch[0]);

        // Update session - use extracted date or default to today
        updateTicketSession({
            ticketNumber: result.ticket_number,
            serviceDate: result.date ? formatDateDB(result.date) : getCurrentDate(),
            grossLbs: result.gross_lbs,
            tareLbs: result.tare_lbs,
            hauler: result.hauler,
            scaleTicketImage: imageDataUrl
        });

        return result;
    }

    async function analyzeDebrisPhoto(imageDataUrl, containerSize = 30) {
        const apiKey = state.openaiKey || localStorage.getItem('divertscan_openai');
        if (!apiKey) throw new Error('OpenAI API key not configured. Go to Settings.');

        const response = await fetch('https://api.openai.com/v1/chat/completions', {
            method: 'POST',
            headers: { 'Authorization': `Bearer ${apiKey}`, 'Content-Type': 'application/json' },
            body: JSON.stringify({
                model: 'gpt-4o',
                messages: [{
                    role: 'user',
                    content: [
                        { type: 'text', text: `Analyze this ${containerSize}-yard container of construction/demolition debris. Estimate percentage breakdown of visible materials. Return ONLY valid JSON:
{"wood":0-100,"gypsum":0-100,"plastic":0-100,"occ":0-100,"metal":0-100,"concrete":0-100,"block":0-100,"landfill":0-100,"confidence":0-100,"notes":"brief description"}
Percentages MUST total 100. Include landfill for non-recyclable waste.` },
                        { type: 'image_url', image_url: { url: imageDataUrl } }
                    ]
                }],
                max_tokens: 500
            })
        });

        const data = await response.json();
        if (data.error) throw new Error(data.error.message);

        const content = data.choices[0].message.content;
        const jsonMatch = content.match(/\{[\s\S]*\}/);
        if (!jsonMatch) throw new Error('Could not parse debris analysis');

        const result = JSON.parse(jsonMatch[0]);

        const percentages = {
            wood: result.wood || 0,
            gypsum: result.gypsum || 0,
            plastic: result.plastic || 0,
            occ: result.occ || 0,
            metal: result.metal || 0,
            concrete: result.concrete || 0,
            block: result.block || 0,
            landfill: result.landfill || 0
        };

        if (!state.ticketSession.debrisImages) state.ticketSession.debrisImages = [];
        state.ticketSession.debrisImages.push(imageDataUrl);

        setMaterialPercentages(percentages);

        return { raw: result, percentages, confidence: result.confidence, notes: result.notes };
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // DATABASE OPERATIONS - FULL CRUD
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    async function initSupabase() {
        if (state.supabase) return state.supabase;

        if (typeof supabase === 'undefined') {
            await new Promise((resolve, reject) => {
                const script = document.createElement('script');
                script.src = 'https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2';
                script.onload = resolve;
                script.onerror = () => reject(new Error('Failed to load Supabase'));
                document.head.appendChild(script);
            });
        }

        state.supabase = supabase.createClient(CONFIG.SUPABASE_URL, CONFIG.SUPABASE_KEY);
        return state.supabase;
    }

    /**
     * CREATE - Save new ticket
     */
    async function createTicket(projectId) {
        await initSupabase();

        const session = state.ticketSession;
        const breakdown = session.calculatedBreakdown || {};

        const ticketData = {
            project_id: projectId || state.currentProject?.id,
            user_id: state.user?.id,
            ticket_number: session.ticketNumber,
            service_date: session.serviceDate || getCurrentDate(),
            ticket_date: session.serviceDate || getCurrentDate(), // Legacy field
            hauler: session.hauler,
            container_size: session.containerSize,
            gross_lbs: session.grossLbs,
            tare_lbs: session.tareLbs,
            net_lbs: session.netLbs,
            net_tons: session.netTons,
            wood_pct: session.materialBreakdown.wood || 0,
            gypsum_pct: session.materialBreakdown.gypsum || 0,
            plastic_pct: session.materialBreakdown.plastic || 0,
            occ_pct: session.materialBreakdown.occ || 0,
            metal_pct: session.materialBreakdown.metal || 0,
            concrete_pct: session.materialBreakdown.concrete || 0,
            block_pct: session.materialBreakdown.block || 0,
            landfill_pct: session.materialBreakdown.landfill || 0,
            wood_tons: breakdown.wood?.tons || 0,
            gypsum_tons: breakdown.gypsum?.tons || 0,
            plastic_tons: breakdown.plastic?.tons || 0,
            occ_tons: breakdown.occ?.tons || 0,
            metal_tons: breakdown.metal?.tons || 0,
            concrete_tons: breakdown.concrete?.tons || 0,
            block_tons: breakdown.block?.tons || 0,
            landfill_tons: breakdown.landfill?.tons || 0,
            diversion_pct: session.diversionRate,
            diverted_tons: session.netTons ? session.netTons * (session.diversionRate / 100) : 0,
            co2e_avoided: session.co2eAvoided,
            gps_lat: session.gpsLat,
            gps_lng: session.gpsLng,
            ip_address: session.ipAddress,
            captured_at: session.capturedAt,
            scale_ticket_image: session.scaleTicketImage,
            debris_images: JSON.stringify(session.debrisImages || []),
            created_at: new Date().toISOString(),
            audit_id: generateAuditId()
        };

        const { data, error } = await state.supabase.from('tickets').insert([ticketData]).select().single();
        if (error) throw error;

        toast('Ticket created successfully!', 'success');
        return data;
    }

    /**
     * READ - Load tickets for a project
     */
    async function loadTickets(projectId, options = {}) {
        await initSupabase();

        let query = state.supabase
            .from('tickets')
            .select('*')
            .eq('project_id', projectId);

        // Apply date range filter if provided
        if (options.startDate) {
            query = query.gte('service_date', options.startDate);
        }
        if (options.endDate) {
            query = query.lte('service_date', options.endDate);
        }

        // Order by service date, newest first
        query = query.order('service_date', { ascending: false });

        // Limit if specified
        if (options.limit) {
            query = query.limit(options.limit);
        }

        const { data, error } = await query;
        if (error) throw error;
        return data || [];
    }

    /**
     * READ - Load single ticket by ID
     */
    async function loadTicket(ticketId) {
        await initSupabase();

        const { data, error } = await state.supabase
            .from('tickets')
            .select('*')
            .eq('id', ticketId)
            .single();

        if (error) throw error;
        return data;
    }

    /**
     * UPDATE - Update existing ticket
     */
    async function updateTicket(ticketId) {
        await initSupabase();

        const session = state.ticketSession;
        const breakdown = session.calculatedBreakdown || {};

        const ticketData = {
            ticket_number: session.ticketNumber,
            service_date: session.serviceDate,
            ticket_date: session.serviceDate, // Keep in sync
            hauler: session.hauler,
            container_size: session.containerSize,
            gross_lbs: session.grossLbs,
            tare_lbs: session.tareLbs,
            net_lbs: session.netLbs,
            net_tons: session.netTons,
            wood_pct: session.materialBreakdown.wood || 0,
            gypsum_pct: session.materialBreakdown.gypsum || 0,
            plastic_pct: session.materialBreakdown.plastic || 0,
            occ_pct: session.materialBreakdown.occ || 0,
            metal_pct: session.materialBreakdown.metal || 0,
            concrete_pct: session.materialBreakdown.concrete || 0,
            block_pct: session.materialBreakdown.block || 0,
            landfill_pct: session.materialBreakdown.landfill || 0,
            wood_tons: breakdown.wood?.tons || 0,
            gypsum_tons: breakdown.gypsum?.tons || 0,
            plastic_tons: breakdown.plastic?.tons || 0,
            occ_tons: breakdown.occ?.tons || 0,
            metal_tons: breakdown.metal?.tons || 0,
            concrete_tons: breakdown.concrete?.tons || 0,
            block_tons: breakdown.block?.tons || 0,
            landfill_tons: breakdown.landfill?.tons || 0,
            diversion_pct: session.diversionRate,
            diverted_tons: session.netTons ? session.netTons * (session.diversionRate / 100) : 0,
            co2e_avoided: session.co2eAvoided,
            last_modified: new Date().toISOString(),
            modified_by: state.user?.email || 'unknown'
        };

        const { data, error } = await state.supabase
            .from('tickets')
            .update(ticketData)
            .eq('id', ticketId)
            .select()
            .single();

        if (error) throw error;

        toast('Ticket updated successfully!', 'success');
        return data;
    }

    /**
     * DELETE - Remove ticket
     */
    async function deleteTicket(ticketId) {
        await initSupabase();

        const { error } = await state.supabase
            .from('tickets')
            .delete()
            .eq('id', ticketId);

        if (error) throw error;

        toast('Ticket deleted', 'success');
        return true;
    }

    /**
     * SAVE - Creates or updates based on edit state
     */
    async function saveTicket(projectId) {
        if (state.editingTicketId) {
            return updateTicket(state.editingTicketId);
        } else {
            return createTicket(projectId);
        }
    }

    /**
     * Load projects for current user
     */
    async function loadProjects() {
        await initSupabase();

        const { data, error } = await state.supabase
            .from('projects')
            .select('*')
            .eq('user_id', state.user?.id)
            .order('created_at', { ascending: false });

        if (error) throw error;
        return data || [];
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // REPORT GENERATION - LEED Waste Diversion Format
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    /**
     * Generate LEED-compliant CSV report
     * Format: Date, Ticket No, GWT, Tare, Net, Wood, Gypsum, Plastic, OCC, Metal, Concrete, Block
     */
    function generateLEEDReport(tickets, projectName = '') {
        // Headers matching LEED Waste Diversion Report format
        const headers = [
            'Date',
            'Ticket No',
            'Gross (lbs)',
            'Tare (lbs)',
            'Net (lbs)',
            'Net (tons)',
            'Wood (tons)',
            'Gypsum (tons)',
            'Plastic (tons)',
            'OCC (tons)',
            'Metal (tons)',
            'Concrete (tons)',
            'Block (tons)',
            'Landfill (tons)',
            'Diverted (tons)',
            'Diversion %'
        ];

        let csv = '';
        
        // Add report header
        if (projectName) {
            csv += `LEED Waste Diversion Report - ${projectName}\n`;
            csv += `Generated: ${new Date().toLocaleDateString()}\n\n`;
        }
        
        csv += headers.join(',') + '\n';

        // Calculate totals
        let totals = {
            gross: 0, tare: 0, net: 0, netTons: 0,
            wood: 0, gypsum: 0, plastic: 0, occ: 0,
            metal: 0, concrete: 0, block: 0, landfill: 0,
            diverted: 0
        };

        for (const t of tickets) {
            const row = [
                formatDate(t.service_date || t.ticket_date),
                t.ticket_number || '',
                t.gross_lbs || 0,
                t.tare_lbs || 0,
                t.net_lbs || 0,
                (t.net_tons || 0).toFixed(3),
                (t.wood_tons || 0).toFixed(3),
                (t.gypsum_tons || 0).toFixed(3),
                (t.plastic_tons || 0).toFixed(3),
                (t.occ_tons || 0).toFixed(3),
                (t.metal_tons || 0).toFixed(3),
                (t.concrete_tons || 0).toFixed(3),
                (t.block_tons || 0).toFixed(3),
                (t.landfill_tons || 0).toFixed(3),
                (t.diverted_tons || 0).toFixed(3),
                (t.diversion_pct || 0) + '%'
            ];
            csv += row.join(',') + '\n';

            // Accumulate totals
            totals.gross += parseFloat(t.gross_lbs) || 0;
            totals.tare += parseFloat(t.tare_lbs) || 0;
            totals.net += parseFloat(t.net_lbs) || 0;
            totals.netTons += parseFloat(t.net_tons) || 0;
            totals.wood += parseFloat(t.wood_tons) || 0;
            totals.gypsum += parseFloat(t.gypsum_tons) || 0;
            totals.plastic += parseFloat(t.plastic_tons) || 0;
            totals.occ += parseFloat(t.occ_tons) || 0;
            totals.metal += parseFloat(t.metal_tons) || 0;
            totals.concrete += parseFloat(t.concrete_tons) || 0;
            totals.block += parseFloat(t.block_tons) || 0;
            totals.landfill += parseFloat(t.landfill_tons) || 0;
            totals.diverted += parseFloat(t.diverted_tons) || 0;
        }

        // Add totals row
        const overallDiversion = totals.netTons > 0 
            ? ((totals.diverted / totals.netTons) * 100).toFixed(1) 
            : 0;

        csv += '\n';
        csv += [
            'TOTALS',
            tickets.length + ' tickets',
            totals.gross.toFixed(0),
            totals.tare.toFixed(0),
            totals.net.toFixed(0),
            totals.netTons.toFixed(3),
            totals.wood.toFixed(3),
            totals.gypsum.toFixed(3),
            totals.plastic.toFixed(3),
            totals.occ.toFixed(3),
            totals.metal.toFixed(3),
            totals.concrete.toFixed(3),
            totals.block.toFixed(3),
            totals.landfill.toFixed(3),
            totals.diverted.toFixed(3),
            overallDiversion + '%'
        ].join(',') + '\n';

        // Add LEED compliance status
        csv += '\n';
        csv += `LEED v5 Target: 75%\n`;
        csv += `Project Diversion Rate: ${overallDiversion}%\n`;
        csv += `Status: ${parseFloat(overallDiversion) >= 75 ? 'COMPLIANT âœ“' : 'BELOW TARGET'}\n`;

        return csv;
    }

    /**
     * Download CSV file
     */
    function downloadCSV(csv, filename) {
        const blob = new Blob([csv], { type: 'text/csv' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = filename || `DivertScan-Report-${getCurrentDate()}.csv`;
        a.click();
        URL.revokeObjectURL(url);
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // PUBLIC API
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    return {
        // Configuration
        CONFIG,
        MATERIALS,
        MATERIAL_KEYS,
        
        // State access
        getState: () => state,
        setState: (key, value) => { state[key] = value; },
        setOpenAIKey: (key) => { state.openaiKey = key; localStorage.setItem('divertscan_openai', key); },
        
        // Utilities
        toast,
        formatNumber,
        formatDate,
        formatDateDB,
        getCurrentDate,
        generateAuditId,
        
        // Calculations
        calculateNetWeight,
        calculateMaterialTonnages,
        validateMaterialTotal,
        recalculateTicket,
        
        // Ticket session (CRUD-ready)
        initTicketSession,
        loadTicketForEdit,
        updateTicketSession,
        setMaterialPercentages,
        updateMaterialPercentage,
        getTicketSession,
        isEditingTicket,
        
        // Scale Integration
        isScaleSupported,
        connectScale,
        disconnectScale,
        fetchScaleData,
        getScaleStatus,
        
        // Verification
        captureGPS,
        captureIP,
        
        // AI Analysis
        analyzeScaleTicket,
        analyzeDebrisPhoto,
        
        // Database CRUD
        initSupabase,
        createTicket,
        loadTickets,
        loadTicket,
        updateTicket,
        deleteTicket,
        saveTicket,  // Smart save (create or update)
        loadProjects,
        
        // Reports
        generateLEEDReport,
        downloadCSV,
        
        // Version
        version: CONFIG.VERSION
    };
})();

// Export for module systems
if (typeof module !== 'undefined' && module.exports) {
    module.exports = DivertScan;
}

// Make globally available
window.DivertScan = DivertScan;
